<p>
    Shadowing parent class members by creating fields, properties and methods with the same signatures as non-<code>virtual</code>
    parent class members can result in seemingly strange behavior if an instance of the child class is cast to the parent class.
    In such cases, the parent class' code will be executed instead of the code in the child class, confusing callers and
    potentially causing hard-to-find bugs.
</p>
<p>
    Instead the child class member should be renamed and the issue that created the need for shadowing should be resolved.
</p>
<p>
    This rule ignores <code>private</code> parent class members, and any method named <code>Equals</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...

  public double GetCost()
  {
    return 3.5;
  }
}

public class Raspberry : Fruit
{
  private bool ripe;  // Noncompliant
  private static Color FLESH; // Noncompliant

  public new double GetCost()  // Noncompliant
  {
    return 7.5;
  }
}

// ...
var r = new Raspberry();
var f = (Fruit) r;
Console.WriteLine(r.GetCost());  // prints 7.5
Console.WriteLine(f.GetCost());  // prints 3.5; there's only one instance but different code executes depending on cast
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...

  public double GetCost()
  {
    return 3.5;
  }
}

public class Raspberry : Fruit
{
  private bool ripened;
  private static Color FLESH_COLOR;

  public double GetInflatedCost()
  {
    return 7.5;
  }
}

// ...
var r = new Raspberry();
var f = (Fruit) r;
Console.WriteLine(r.GetCost());  // prints 3.5
Console.WriteLine(f.GetCost());  // prints 3.5; same code executes every time
Console.WriteLine(r.GetInflatedCost()); // prints 7.5
</pre>
